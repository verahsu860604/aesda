# -*- coding: utf-8 -*-
"""state_of_health.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aMC2rv3Qp-_7vDfKPeoZRocrQEOYqj1N

## State-of-Health Estimation

### Fitting State-of-Health Curve Fitting
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import matplotlib.pyplot as plt
# %matplotlib inline

curve_data = np.array([
    [2, 10000000],
    [4, 1000000],
    [17, 100000],
    [30, 40000],
    [60, 10000],
    [100, 3000]
])

plt.plot(curve_data[:, 0], curve_data[:, 1])
plt.yscale('log')

plt.grid()
plt.show()

"""Proposed function:
$ C(dod) = \frac{3.5 * 10^7}{x^2} $
"""

def get_cycles(DoD):
  return 3.5 / (DoD ** 2) * 10e6

x = np.linspace(0, 100, 50)
y = get_cycles(x)


plt.plot(curve_data[:, 0], curve_data[:, 1])
plt.plot(x, y)

plt.yscale('log')

plt.grid()
plt.show()



"""### Depth of Discharge and Cycles 

Reference: 


[Main] Shi, Yuanyuan, Bolun Xu, Yushi Tan, and Baosen Zhang. "A convex cycle-based degradation model for battery energy storage planning and operation." In 2018 Annual American Control Conference (ACC), pp. 4590-4596. IEEE, 2018.


Millner, Alan. "Modeling lithium ion battery degradation in electric vehicles." In 2010 IEEE Conference on Innovative Technologies for an Efficient and Reliable Electricity Supply, pp. 349-356. IEEE, 2010.
"""

def get_DoD_and_Cycles(y):
  TH = 20 # 20% Threshold
  y = np.array(y)
  avg = y.mean()
  std = y.std()
  downwards = y[1:] - y[:-1]

  cycles = []
  cum = 0
  for i in range(1, len(downwards)):
    if downwards[i] < 0:
      cum += abs(downwards[i])
    else:
      if cum > TH:
        cycles.append(cum)
        cum = 0

  if cum > TH:
    cycles.append(cum)
    cum = 0
  cycles.append(cum)
  return np.array(cycles).mean(), len(cycles)

time_n = 100
x = np.linspace(1, time_n, time_n)
y = 30 * np.sin(x) + 60 + 10 * np.random.random(x.shape)

plt.figure(figsize=(14,7))
plt.ylim([0, 100])
plt.plot(x, y)
plt.grid()
dod, cycles = get_DoD_and_Cycles(y)
plt.title('DoD = ' + str(dod) + '    Cycles=' + str(cycles))
plt.show()

time_n = 100

def generate_random_data(time_n):

  x = np.linspace(1, time_n, time_n)

  y = [50]

  dist = np.random.randint(10, 50)
  for i in range(time_n - 1):
    y.append(max(0, min(100, y[-1] + dist * (np.random.random() - 0.5))))
  return x, y

x, y = generate_random_data(time_n)
plt.figure(figsize=(14,7))
plt.plot(x, y)
dod, cycles = get_DoD_and_Cycles(y)
plt.title('DoD = ' + str(dod) + '    Cycles=' + str(cycles))
plt.grid()
plt.show()



"""### Update Function of Equation(18)"""

def fh(y):
  DoD, cycles = get_DoD_and_Cycles(y)
  estimated_cycles = get_cycles(DoD)
  return cycles / estimated_cycles

init_health = 1

weekly_data = np.array([
    generate_random_data(20)[1] for i in range(20)
])

print(weekly_data.shape)

weeks = np.linspace(1, 20, 20)
y = [1]
for i in range(20):
  y.append(y[-1] - fh(weekly_data[i]))
plt.figure(figsize=(14,7))
plt.plot(weeks, y[1:])
plt.grid()
plt.show()

